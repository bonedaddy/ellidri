//! Message parsing, with the list of commands and replies.
//!
//! See the documentation of `Message` for more details.

use std::ops::Range;

pub use rpl::Reply;
use std::fmt;

/// The list of IRC replies.
///
/// Source: https://tools.ietf.org/html/rfc2812.html#section-5
pub mod rpl {
    /// The type used for all replies in this module.
    ///
    /// Used to ease any BrEaKiNg ChAnGe that may happen.
    pub type Reply = &'static str;

    pub const WELCOME: Reply   = "001";
    pub const YOURHOST: Reply  = "002";
    pub const CREATED: Reply   = "003";
    pub const MYINFO: Reply    = "004";

    pub const CHANNELMODEIS: Reply = "324";
    pub const NOTOPIC: Reply       = "331";
    pub const TOPIC: Reply         = "332";
    pub const NAMREPLY: Reply      = "353";
    pub const ENDOFNAMES: Reply    = "366";
    pub const MOTD: Reply          = "372";
    pub const MOTDSTART: Reply     = "375";
    pub const ENDOFMOTD: Reply     = "376";

    pub const ERR_NOSUCHCHANNEL: Reply    = "403";
    pub const ERR_CANNOTSENDTOCHAN: Reply = "404";
    pub const ERR_UNKNOWNCOMMAND: Reply   = "421";
    pub const ERR_NONICKNAMEGIVEN: Reply  = "431";
    pub const ERR_NICKNAMEINUSE: Reply    = "433";
    pub const ERR_NOTONCHANNEL: Reply     = "442";
    pub const ERR_NOTREGISTERED: Reply    = "451";
    pub const ERR_NEEDMOREPARAMS: Reply   = "461";
    pub const ERR_ALREADYREGISTRED: Reply = "462";
    pub const ERR_YOUREBANNEDCREEP: Reply = "465";
}

/// Code generation for the list of commands.
///
/// # Usage
///
/// ```rust
/// commands! {
///     CommandIdentifier => num_params,
///     // ...
/// }
/// ```
///
/// `num_params` is the number of required parameters for this command.
macro_rules! commands {
    ( $( $cmd:ident => $n:expr, )* ) => {
        /// The list of commands, generated by `commands!`.
        ///
        /// Unknown commands and replies are supported by `Message` directly,
        /// this enum just contains the supported commands.
        #[derive(Clone, Copy, Debug, PartialEq)]
        pub enum Command { $( $cmd ),* }

        impl Command {
            /// From a given command string, returns the corresponding command,
            /// or `None` otherwise.
            ///
            /// It ignores the case of its argument.
            ///
            /// # Example
            ///
            /// ```rust
            /// use ellidri::message::Command;
            ///
            /// let join = Command::parse("join");
            /// let join2 = Command::parse("JOIN");
            /// let not_join = Command::parse("jjoin");
            ///
            /// assert_eq!(join, Some(Command::Join));
            /// assert_eq!(join2, Some(Command::Join));
            /// assert_eq!(not_join, None);
            /// ```
            pub fn parse(s: &str) -> Option<Command> {
                $( if s.eq_ignore_ascii_case(stringify!($cmd)) {
                    Some(Command::$cmd)
                } else )* {
                    None
                }
            }

            /// Returns true if `n` is equal or above the number of required
            /// arguments for the command.
            ///
            /// # Example
            ///
            /// ```rust
            /// use ellidri::message::Command;
            ///
            /// let privmsg = Command::parse("Privmsg").unwrap();
            ///
            /// assert_eq!(privmsg.has_enough_params(3), true);
            /// assert_eq!(privmsg.has_enough_params(2), true);
            /// assert_eq!(privmsg.has_enough_params(1), false);
            /// ```
            #[allow(unused_comparisons)]
            pub fn has_enough_params(&self, n: usize) -> bool {
                match self {
                $(
                    Command::$cmd => n >= $n,
                )*
                }
            }

            /// Returns the command string. It is not the string that have been
            /// parsed.
            ///
            /// # Example
            ///
            /// ```rust
            /// use ellidri::message::Command;
            ///
            /// let quit = Command::parse("QUIT").unwrap();
            ///
            /// assert_eq!(quit.as_str(), "Quit");
            /// ```
            pub fn as_str(&self) -> &'static str {
                match self {
                $(
                    Command::$cmd => stringify!($cmd),
                )*
                }
            }
        }

        impl fmt::Display for Command {
            /// Simply writes the output of `Command::as_str`. Used by
            /// `Message::new`.
            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
                write!(f, "{}", self.as_str())
            }
        }
    }
}

/// Represents an IRC message, with its prefix (source), command and parameters.
///
/// This type is a wrapper around a `String`. It means that when
/// `Message::parse` is called, the string is kept intact, and each component of
/// the message are stored as indexes of the string. The only allocation is
/// the vector for the parameters.
///
/// See `Message::new` and `Message::parse` for usage examples.
#[derive(Clone, Debug)]
pub struct Message {
    /// Message buffer. Instead of having a string for the source, the command,
    /// and each parameter, there's only one string. The other struct members
    /// refer to indexes in the string (not unicode points).
    ///
    /// TODO: Replace it with `Cow<'a, str>` to avoid allocation when parsing
    /// `&str`.
    buf: String,

    /// The source of the message.
    prefix: Option<Range<usize>>,

    /// Either a known `Command`, or the range of indexes in `self.buf` where
    /// the command string is.
    ///
    /// Either this is `Ok(c)`, and the command string is `c.as_str()`, or this
    /// is `Err(Range { start, end })`, and the command string is
    /// `self.buf[start..end]`.
    command: Result<Command, Range<usize>>,

    /// The list of indexes where each parameter is.
    ///
    /// TODO: maybe change it to a `[Range<usize>; 15]`, as there *shouldn't* be
    /// more than 15 parameters in a message.
    params: Vec<Range<usize>>,
}

impl Message {
    /// Creates a new message from the given `prefix`, `command` and `params`.
    ///
    /// # Example
    ///
    /// ```rust
    /// use ellidri::message::{Message, rpl};
    ///
    /// let msg = Message::new("ellidri.chat",
    ///                        rpl::WELCOME,
    ///                        &["john", "Welcome to the IRC network!"]);
    ///
    /// assert_eq!(
    ///     msg.as_ref(),
    ///     &b":ellidri.chat 001 john :Welcome to the IRC network!\r\n"[..]);
    /// ```
    ///
    /// # Todos
    ///
    /// TODO to make this more usable:
    /// - make `prefix` optional.
    /// - make `command` either a `Command` or a `Reply`. Maybe this should be
    ///   done by making a `Command::Reply` variant.
    /// - make `params` an iterator instead of slice, to be more general.
    ///
    /// TODO to make this lighter:
    /// - currently this creates the whole buffer, but it shouldn't. Instead
    ///   it should make references to the arguments. This needs more than just
    ///   changing `self.buf` to a `Cow<'a, str>`. `cookie-rs` can be a source
    ///   of inspiration.
    ///
    /// TODO to make this safer:
    /// - check for spaces in `prefix` and each `params[..params.len()-1]`, and
    ///   return an error (or panic? since it's an error in the program. maybe
    ///   not, just print a warning).
    /// - check for ':' at the first char of each `params[..]`.
    pub fn new<C>(prefix: &str, command: C, params: &[&str]) -> Message
        where C: fmt::Display
    {
        let mut buf = format!(":{} {}", prefix, command);
        let prefix = Range {
            start: 1,
            end: 1 + prefix.len(),
        };
        let command = Range {
            start: prefix.end + 1,
            end: buf.len(),
        };
        let mut param_ranges = Vec::new();

        for i in 0..params.len() {
            buf.push(' ');
            if i + 1 == params.len() {
                buf.push(':');
            }
            // Don't count the ':' in the last param.
            let start = buf.len();
            buf.push_str(params[i]);
            let end = buf.len();
            param_ranges.push(Range { start, end })
        }
        buf.push('\r');
        buf.push('\n');
        Message {
            buf,
            prefix: Some(prefix),
            command: Err(command),
            params: param_ranges,
        }
    }

    /// Wraps the given string into a `Message` type, that allows to get its
    /// source, the command and each parameter.
    ///
    /// This function accepts strings with or without "\r\n", or any whitespace.
    ///
    /// Relevant source of information:
    /// https://tools.ietf.org/html/rfc2812.html#section-2.3
    ///
    /// # Example
    ///
    /// ```rust
    /// use ellidri::message::{Command, Message};
    ///
    /// let msg = Message::parse(":kawai PRIVMSG #kekbab :You must be joking!")
    ///     .unwrap()   // The message was parsed successfully.
    ///     .unwrap();  // The message is not empty.
    ///
    /// assert_eq!(msg.prefix(), Some("kawai"));
    /// assert_eq!(msg.command(), Ok(Command::PrivMsg));
    /// assert_eq!(msg.param(1), "You must be joking!");  // Second parameter.
    /// assert_eq!(msg.param_opt(2), None);  // There is no third parameter.
    ///
    /// let unknown = Message::parse("waitwhat #admin hello there")
    ///     .unwrap().unwrap();
    ///
    /// assert_eq!(unknown.prefix(), None);
    /// assert_eq!(unknown.command(), Err("waitwhat"));  // Unknown command.
    /// assert_eq!(unknown.param(0), "#admin");
    /// assert_eq!(unknown.param_opt(1), Some("hello"));
    /// ```
    ///
    /// # Return value
    ///
    /// Returns `Ok(Some(msg))` when the message is correctly formed, `Ok(None)`
    /// when the message is empty (see note below), and `Err(reply)` when the
    /// message is invalid and the server should send the client a reply with
    /// the returned `reply` code.
    ///
    /// **Note:** An empty message doesn't mean just "\r\n", but actually any
    /// whitespace string. For example:
    ///
    /// ```rust
    /// use ellidri::message::Message;
    ///
    /// let empty = Message::parse("  \r \n \t ");
    ///
    /// assert!(empty.is_ok());
    /// assert!(empty.unwrap().is_none());
    /// ```
    pub fn parse<S>(s: S) -> Result<Option<Message>, Reply>
        where S: Into<String>
    {
        let buf = s.into();

        // Split the buffer into words. This takes care of triming the "\r\n" at
        // the end of `buf`, and any additional whitespace between parameters,
        // the command or the source.
        let mut words = buf.split_whitespace();

        let mut prefix = None;
        let command = if let Some(word) = words.next() {
            if word.starts_with(':') {
                // The first word is the prefix.
                let mut prefix_range = range_of(word, &buf);
                prefix_range.start += 1;  // Exclude the ':'
                prefix = Some(prefix_range);
                let word = words.next().ok_or(rpl::ERR_YOUREBANNEDCREEP)?;
                parse_message_command(word, &buf)
            } else {
                // The first word is the command.
                parse_message_command(word, &buf)
            }
        } else {
            // There is no first word, the string is just whitespace.
            return Ok(None);
        };

        let mut params = Vec::new();

        for word in words {
            if word.starts_with(':') {
                // The word is the first word of the trailing (last) parameter.
                params.push(last_range_of(word, &buf));
                break;
            }

            // This word is not the trailing parameter.
            params.push(range_of(word, &buf));
        }

        Ok(Some(Message { buf, prefix, command, params }))
    }

    /// Returns the source of the message, if any.
    ///
    /// # Example
    ///
    /// ```rust
    /// use ellidri::message::Message;
    ///
    /// let with = Message::parse(":botte PRIVMSG #agora :I'm listening")
    ///     .unwrap().unwrap();
    /// let without = Message::parse("JOIN #agora")
    ///     .unwrap().unwrap();
    ///
    /// assert_eq!(with.prefix(), Some("botte"));
    /// assert_eq!(without.prefix(), None);
    /// ```
    pub fn prefix(&self) -> Option<&str> {
        self.prefix.as_ref().map(|range| &self.buf[range.clone()])
    }

    /// Either returns the `Command` variant of this message, or returns the
    /// raw command string if it's unknown.
    ///
    /// # Example
    ///
    /// ```rust
    /// use ellidri::message::{Command, Message};
    ///
    /// let known = Message::parse("JOIN #minecraft")
    ///     .unwrap().unwrap();
    /// let unknown = Message::parse("MaliCIOUS #h4ck3R")
    ///     .unwrap().unwrap();
    ///
    /// assert_eq!(known.command(), Ok(Command::Join));
    /// // The case is the same because it's a reference
    /// // to the string passed to `Message::parse`.
    /// assert_eq!(unknown.command(), Err("MaliCIOUS"));
    /// ```
    pub fn command(&self) -> Result<Command, &str> {
        match self.command {
            Ok(cmd) => Ok(cmd),
            Err(ref range) => Err(&self.buf[range.clone()]),
        }
    }

    /// Returns the number of parameters in the message.
    ///
    /// # Example
    ///
    /// ```rust
    /// use ellidri::message::Message;
    ///
    /// let topic = Message::parse("TOPIC #saucisse :Best chan of the world!?!")
    ///     .unwrap().unwrap();
    ///
    /// assert_eq!(topic.num_params(), 2);
    /// ```
    pub fn num_params(&self) -> usize {
        self.params.len()
    }

    /// Returns the `i`th parameter. Panics if `i` is out of bounds.
    ///
    /// # Example
    ///
    /// ```rust
    /// use ellidri::message::Message;
    ///
    /// let topic = Message::parse("TOPIC #saucisse :Best chan of the world!?!")
    ///     .unwrap().unwrap();
    ///
    /// assert_eq!(topic.param(0), "#saucisse");
    /// assert_eq!(topic.param(1), "Best chan of the world!?!");
    /// ```
    pub fn param(&self, i: usize) -> &str {
        &self.buf[self.params[i].clone()]
    }


    /// Returns the `i`th parameter, or `None` if `i` is out of bounds.
    ///
    /// # Example
    ///
    /// ```rust
    /// use ellidri::message::Message;
    ///
    /// let topic = Message::parse("TOPIC #saucisse")
    ///     .unwrap().unwrap();
    ///
    /// assert_eq!(topic.param_opt(0), Some("#saucisse"));
    /// assert_eq!(topic.param_opt(1), None);
    /// ```
    pub fn param_opt(&self, i: usize) -> Option<&str> {
        self.params.get(i).map(|range| &self.buf[range.clone()])
    }

    /// Returns true if the message has enough parameters for its command.
    ///
    /// Also returns true if the message has too much parameters for its
    /// command. false is only returned when there's not enough of them.
    ///
    /// # Example
    ///
    /// ```rust
    /// use ellidri::message::Message;
    ///
    /// let nick = Message::parse("NICK i_suck_dice").unwrap().unwrap();
    /// assert_eq!(nick.has_enough_params(), true);
    ///
    /// let nick = Message::parse("NICK :").unwrap().unwrap();
    /// assert_eq!(nick.has_enough_params(), true);
    ///
    /// let nick = Message::parse("NICK").unwrap().unwrap();
    /// assert_eq!(nick.has_enough_params(), false);
    /// ```
    pub fn has_enough_params(&self) -> bool {
        match self.command {
            Ok(cmd) => cmd.has_enough_params(self.num_params()),
            Err(_) => false,
        }
    }
}

impl AsRef<[u8]> for Message {
    /// Returns the message string as bytes. Used by the `crate::net` module
    /// with `tokio::io::write_all`.
    fn as_ref(&self) -> &[u8] {
        self.buf.as_bytes()
    }
}

impl fmt::Display for Message {
    /// Displays the message as a correctly formed message. Used for logging.
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.buf.trim_end())
    }
}

commands! {
    Join => 1,
    Mode => 1,
    Motd => 0,
    Nick => 1,
    Part => 1,
    Ping => 1,
    Pong => 1,
    PrivMsg => 2,
    Quit => 0,
    Topic => 1,
    User => 4,
}

/// For the given `word`, that is part of the given `buf`, returns the
/// matching `Command`, or the index of `word` in `buf` otherwise.
///
/// `word` must be part (i.e. a word of) of `buf`, otherwise this function
/// might panic (a.k.a. undefined behavior)...
fn parse_message_command(word: &str, buf: &str) -> Result<Command, Range<usize>> {
    Command::parse(word).ok_or_else(|| range_of(word, buf))
}

/// Returns the index of the `inner` string in the `outer` string.
///
/// If `inner` is not "inside" `outer` in memory, this function has undefined
/// behavior (panics if `inner` is before `outer` in memory, returns nonsense
/// otherwise).
///
/// # Example
///
/// ```rust,ignore
/// let outer = "Hello world!";
/// let inner = &outer[0..5];  // "Hello"
/// assert_eq!(range_of(inner, outer), Range { start: 0, end: 5 });
/// ```
fn range_of(inner: &str, outer: &str) -> Range<usize> {
    let inner_len = inner.len();
    let inner = inner.as_ptr() as usize;
    let outer = outer.as_ptr() as usize;
    let start = inner - outer;
    let end = start + inner_len;
    Range { start, end }
}

/// Returns the index of the trailing parameter of `outer`, where `inner` is the
/// first word of the parameter and contains the ':'.
///
/// As `range_of`, `inner` must refer to memory inside `outer`, or similar
/// behavior will show up.
///
/// # Example
///
/// ```rust,ignore
/// let outer = "Hello :world !";
/// let inner = &outer[6..11];  // ":world"
/// let range = last_range_of(inner, outer);
/// assert_eq!(outer[range], "world !");
/// ```
fn last_range_of(inner: &str, outer: &str) -> Range<usize> {
    let outer_len = outer.trim_end().len();
    let inner = inner.as_ptr() as usize;
    let outer = outer.as_ptr() as usize;
    let start = inner - outer + 1;  // Don't count the ':'.
    let end = outer_len;
    Range { start, end }
}
